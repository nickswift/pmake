#!/usr/bin/perl
# Partner: Nicholas Wood (njwood@ucsc.edu)
# Partner: William Cork (wcork@ucsc.edu)
use strict;
use warnings;

# imports
use Getopt::Std;
use Cwd;

# use getopts in the canonical fashion
my %opts;
getopts('dnf:', \%opts);

my $debug_mode = (exists $opts{'d'}) ? 1          : 0;
my $nex_mode   = (exists $opts{'n'}) ? 1          : 0;
my $makefile   = (exists $opts{'f'}) ? $opts{'f'} : 'Makefile';

# Regexes
my $regex_macro   = qr/^[\w\$\{\}^\t]+ *\:?= *[\w\$\{\}\.\%\- ]+$/;
my $regex_target  = qr/^[\w\$\{\}\.^\t]+ *\: *([^ ].*)?$/;
my $regex_pattern = qr/^%\.[\w\$\{\}\.^\t]+ *\: *.*$/;

# ------------------------------------------------------------------------------
# SUBROUTINES: HELPER FUNCTIONS
# ------------------------------------------------------------------------------
sub debug_print ($)
{
  if ($debug_mode) {
    my $msg = shift;
    print("$msg\n");
  }
}

# run_system_command: Runs passed command and handles the minus make operator
sub run_system_command ($)
{
  my ($input, $command, $term_signal, $ignore_status, $core_dumped, $exit_status);

  $input         = shift;
  $command       = undef;
  $ignore_status = 0;

  debug_print("Running command: $input");
  if ($input =~ m/^-/) {
    $command = $input;
    $command =~ s/^(-| )+//;
    debug_print("Command $command Error will be ignored");
    $ignore_status = 1;
  } else {
    $command = $input;
    debug_print("Command $command Error will not be ignored");
  }
  my @args   = split(m/ /, $command);
  my $output = system(@args); #or exit ($?);
  my $return_status = $?;
  $term_signal = $? & 0x7F;
  $core_dumped = $? & 0x80;
  $exit_status = ($? >> 8) & 0xFF;

if ($return_status != 0) {
  debug_print("Return status: $return_status");
  debug_print("Term Signal: $term_signal");
  debug_print("Core Dumped: $core_dumped");
  debug_print("Exit Status: $exit_status");
  }
  if($exit_status != 0) {
    if($ignore_status == 1) {
        debug_print("Return status ignored");
    } else {
        debug_print("BAD Command");
        exit ($exit_status);
    }
  }
}

# ------------------------------------------------------------------------------
# SUBROUTINES: FILE MANAGEMENT
# ------------------------------------------------------------------------------
# subs_openfile: Reads entire file from first argument and returns it as string.
sub read_makefile ($)
{
  my $file_location = shift;
  debug_print("Reading in: $file_location ... ");
  local $/=undef;

  open MAKEFILE, $file_location 
    or die("Makefile:$file_location could not be opened\n");
  
  my $file_contents = <MAKEFILE>;
  debug_print("DONE");
  close MAKEFILE;
  return $file_contents;
}

# ------------------------------------------------------------------------------
# SUBROUTINES: MACROS 
# ------------------------------------------------------------------------------
my %macros;
my %targets;
my $first_target;
my $active_target;
my %pattern_targets;
my $active_pattern_target;

# Find a macro key inside the macro hash -- die if it's not found
# $ --> the name to look up
sub find_macro ($)
{
  my $key = shift;
  my $val = $macros{$key} or die("ERR: MACRO $key NOT FOUND");
  return $val;
}

# Evaluates a macro value
sub eval_macros ($)
{
  # the following line-noise interprets a macro's ${} values by looking them
  # up in the relevant hash and replacing instances of that sequence in the
  # original value string
  my $raw_val = shift;
  my $val     = $raw_val;
  while($raw_val =~  m/(\${[^}]+})/g) {
    my ($tmp_macro, $repl);

    # extract key and find it in the macro hash
    $tmp_macro =  $1;
    $tmp_macro =~ m/([^\${}]+)/;
    $repl      =  find_macro($1);

    # escape the "$" before doing the regex replace
    $tmp_macro =~ s/\$/\\\$/g;
    $val       =~ s/$tmp_macro/$repl/e;
  }
  return $val;
}

sub add_macro ($)
{
  my $line = shift;
  $line =~ m/([\w\$\{\}]+) *\:?= *([\w\$\{\}\. ]+)/;
  my $key = $1;
  my $val = $2;

  # detect an eval_macros
  if ($line =~ m/\:/) {
    $val = eval_macros($val);
  }

  $macros{$key} = $val;
}

sub eval_target_macros ($$)
{
  my ($tindex, $raw_val, $val, $tmp_macro, $repl);
  $tindex  = shift;
  $raw_val = shift;
  $val     = $raw_val;

  # dereference target
  my %target = %{$targets{$tindex}};

  # evaluate local macros
  while ($raw_val =~ m/(\$@|\$\^|\$<)/g) {
    # get correct macro replacement value
    $tmp_macro = $1;
    if    ($tmp_macro eq '\$@') { $repl = $tindex;                      }
    elsif ($tmp_macro eq '\$^') { $repl = join(' ', @{$target{'deps'}});}
    elsif ($tmp_macro eq '\$<') { $repl = $target{'firstdep'};          }
    else                        { die('this shouldn\'t be reachable');  }
    # do replacement
    $tmp_macro =~ s/\$/\\\$/g;
    $val       =~ s/$tmp_macro/$repl/e;
  }

  # debug_print("$val");
  return $val;
}

# input can either be the right side of a macro, or the full command
# from inside a target
sub eval_command ($$)
{
  my ($tindex, $raw_cmd);
  $tindex  = shift;
  $raw_cmd = shift;

  # find the target we're looking at
  my %target  = %{$targets{$tindex}};
  $raw_cmd = eval_target_macros($tindex, $raw_cmd);

  # Get values of global macros first
  return eval_macros($raw_cmd);
}

# ------------------------------------------------------------------------------
# SUBROUTINES: TARGETS 
# ------------------------------------------------------------------------------

sub add_target_general ($$)
{
  # unset active target flags
  $active_target         = undef;
  $active_pattern_target = undef;

  my $thash    = shift;
  my $line     = shift;
  $line        =~ m/([\w\$\{\}\.%]+) *\: *([\w\$\{\}\.% ]*)/;
  my $output   = $1;

  # evaluate macros in the target's name
  $output = eval_macros($output);

  # evaluate macros in the target's dependency list
  my $raw_deps = defined($2) ? $2 : '';
  $raw_deps    = eval_macros($raw_deps);

  # pull dependency list apart by space
  my @deps = split(m/ /, $raw_deps);
  my @cmds = ();

  # define the target as another hash
  my %target;

  # check whether the target exists already
  if (exists($thash->{$output})) {
    # Append dependencies to this target's extant dependency list
    %target = %{$thash->{$output}};
    for my $dep (@deps) {
      push(@{$target{'deps'}}, $dep);
    }
  } else {
    # check for file
    # TODO: also check timestamp to see if it has been modified since last build
    $target{'built'}    = (-e $output) ? 1 : 0;
    $target{'deps'}     = \@deps;
    $target{'cmds'}     = \@cmds;
    $target{'firstdep'} = $deps[0];
    $thash->{$output}   = \%target;
  }

  $first_target  = defined($first_target) ? $first_target : $output;
  return \%target;
}

sub add_target ($)
{
  my $output = shift;
  $active_target = add_target_general(\%targets, $output);
  debug_print("ADDING TARGET: $output --> $active_target");
}

# being sure to prototype the function so it can recurse
sub build_target_output ($);

# build the output of a target
sub build_target_output ($)
{
  my ($target, $dep, $cmd);
  my %macros_local;
  $target = shift;

  # If there's no target, look for a file, otherwise build the target
  if (!exists($targets{$target})) { 
    debug_print("TARGET \"$target\" DOES NOT EXIST");
    if (-e $target) {
      return;
    }
  }

  my @deps     = @{$targets{$target}->{'deps'}};
  my @commands = @{$targets{$target}->{'cmds'}};

  debug_print("BUILDING TARGET: $target");

  # Step through dependencies and ensure they've been built
  for $dep (@deps) {
    if ($targets{$target}->{'built'} == 0) {
      build_target_output($dep);
    }
  }

  # step through the commands in this target
  for $cmd (@commands) {
    # remove tabs
    $cmd =~ s/\t//g;

    # first, evaluate target macros in this line
    debug_print("EVALUATING $cmd");
    $cmd = eval_command($target, $cmd);
    
    # detected local macro
    if ($cmd =~ /${regex_macro}/) {
      # macros in isolated context
    } else {
      # execute
      debug_print("PLAIN COMMAND: $cmd");

      print("$cmd\n");
      run_system_command($cmd) if (!$nex_mode);
    }
  }
}

#-------------------------------------------------------------------------------
# SUBROUTINES: PATTERN RULES AND PATTERN EXPANSION
#-------------------------------------------------------------------------------
 
sub add_pattern_target ($)
{
  my $output = shift;
  $active_pattern_target = add_target_general(\%pattern_targets, $output);
  debug_print("ADDING PATTERN TARGET: $output --> $active_pattern_target");
}

sub generate_pattern_target ($)
{
  my ($keyword);
  $keyword  = shift;

  my $template = $pattern_targets{$keyword};
  my %target;
  my @deps   = ();
  my @cmds   = ();
  my $output = $keyword;
  $output    =~ s/%(\..+)/$keyword\.$2/g;

  for my $dep (@{$template->{'deps'}}) {
    debug_print("PUSHING: $dep");
    $dep =~ m/(%)(\..+)/;
    push(@deps, "$keyword\.$2");
  }

  for my $cmd (@{$template->{'cmds'}}) {
    my $tmp_cmd =  $cmd;
    $tmp_cmd    =~ s/(%)(\..+)/$keyword\.$2/g;
    push(@cmds, $tmp_cmd);
  }

  $target{'built'}    = 0;
  $target{'deps'}     = \@deps;
  $target{'cmds'}     = \@cmds;
  $target{'firstdep'} = $deps[0];
  $targets{$output}   = \%target;
}

sub expand_pattern_targets ()
{
  my ($pattern, $regex_patt);

  # regex for file extensions
  $regex_patt = qr/%(\.[^ ]+)/;

  # iterate over members of the hash
  foreach my $key (keys %pattern_targets) {
    debug_print("KEY: $key");
    # reset the pattern
    $pattern = undef;

    # pull apart dependencies
    for my $dep (@{$pattern_targets{$key}->{'deps'}}) {
      debug_print("DEP: $dep");
      # first match determines the pattern (because I'm not Richard Stallman)
      if ($dep =~ m/${regex_patt}/) {
        $pattern = $1;
        last;
      }
    }
    debug_print("FOUND PATTERN: $pattern");
    $pattern =~ s/\./\\./g;

    # search for %.whatevers in this directory
    opendir(DIR, getcwd);
    while (my $file = readdir(DIR)) {
      debug_print("TESTING $file");
      # test against pattern
      if ($file =~ m/$pattern/) {
        debug_print("MATCH [$file]");
        # if there's a match, do our thing
        generate_pattern_target($file);
      }
    }
    closedir(DIR);
  }
}

# ------------------------------------------------------------------------------
# SUBROUTINES: MAKEFILE PARSING
# ------------------------------------------------------------------------------
sub parse_makefile ($)
{
  for my $line (split(m/\n/, shift)) {
    # skip over comments
    next if ($line =~ /^.*\#.*$/);

    # match macro lines
    if ($line =~ /${regex_macro}/) {
      $active_target         = undef;
      $active_pattern_target = undef;
      debug_print("MACRO: $line");
      add_macro($line);

    # match pattern target lines
    } elsif ($line =~ /${regex_pattern}/) {
      debug_print("PATTERN TARGET: $line");
      add_pattern_target($line);

    # match target lines
    } elsif ($line =~ /${regex_target}/) {
      debug_print("TARGET: $line");
      add_target($line);

    # match terminal command lines
    } elsif ($line =~ /^[\t].*/) {
      # add commands to target
      if (defined($active_target)) {
        debug_print("[$active_target] CMD: $line");
        push(@{$active_target->{'cmds'}}, $line);
      # add commands to pattern target
      } elsif (defined($active_pattern_target)) {
        debug_print("[$active_pattern_target] CMD TEMPLATE: $line");
        push(@{$active_pattern_target->{'cmds'}}, $line);
      } else {
        die('no active target');
      }
    # ignore everything else
    } else {
      debug_print("LINE: $line");
    }
  }
}

# ------------------------------------------------------------------------------
# MAIN PROGRAM CODE
# ------------------------------------------------------------------------------
sub main ()
{
  my ($mf_contents, $entry_point);
  $mf_contents = read_makefile($makefile);
  parse_makefile($mf_contents);

  debug_print("\n--- EXPANDING PATTERN TARGETS ---\n");
  expand_pattern_targets();

  debug_print("\n--- STARTING BUILD PROCESS ---\n");

  # if there's no argument, default to all and quit
  if ($#ARGV < 0) {
    # look for 'all', if no all default to first target in the hash
    $entry_point = exists($targets{'all'}) ? 'all' : $first_target;
    debug_print("STARTING AT TARGET: $entry_point");
    build_target_output($entry_point);
    return;
  }

  debug_print("STEPPING THROUGH SPECIFIED TARGETS");
  # step through desired build targets
  for my $target (@ARGV) {
    # build 'em
    build_target_output($target);
  }
}

# invoke main subroutine
main();
