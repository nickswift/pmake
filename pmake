#!/usr/bin/perl 
use strict;
use warnings;

# imports
use Getopt::Std;

# use getopts in the canonical fashion
my %opts;
getopts('dnf:', \%opts);

my $debug_mode = (exists $opts{'d'}) ? 1          : 0;
my $nex_mode   = (exists $opts{'n'}) ? 1          : 0;
my $makefile   = (exists $opts{'f'}) ? $opts{'f'} : 'Makefile';

# get the target
my $target = $ARGV[0];
my $mf_contents;
my %targ_root;

# subs_openfile: Reads entire file from first argument and returns it as string.
sub subs_openfile
{
  my $file_location = $_[0];
  if($debug_mode)
  {
    print("Reading in: $file_location ... ");
  }
  local $/=undef;
  open MAKEFILE, $file_location or die("Makefile:$file_location could not be opened\n");
  my $file_contents = <MAKEFILE>;
  if($debug_mode)
  {
    print("DONE\n");
  }
  close MAKEFILE;
  return $file_contents;
}

# TODO: retrieve assignments from makefile 

# TODO: retrieve targets from makefile
sub new_macro_node 
{
  my %node;
  $node{"symbol"} = '=';
  @node{"left"}   = $_[0];
  @node{"right"}  = $_[1];
  return %node;
}

sub new_evalmacro_node
{
  my %node;
  $node{"symbol"} = ':=';
  @node{"left"}   = $_[0];
  @node{"right"}  = $_[1];
  return %node; 
}

sub new_target_node
{
  my %node;
  $node{"symbol"} = ':';
  $node{"output"} = $_[0];
  $node{"deps"}   = $_[1];
  @node{"body"}   = @_[2];
  return %node;
}

# parse a makefile into target scope tree
sub mf_parse 
{
  # regex
  my $macro_regex       = "[A-z0-9_\$\{\}]+ *= *[A-z0-9_\$\{\}]+";
  my $evalmacro_regex   = "[A-z0-9_\$\{\}]+ *\:= *[A-z0-9_\$\{\}]+";
  my $target_regex      = "[A-z0-9_\$\{\}]+ *\: *[A-z0-9_\$\{\}]+";
  my $target_line_regex = "[\t].*"

  my @root;
  my %active_target = undef;

  # read makefile line-by-line
  for my $line (split(/\n/, $_[0])) 
  {
    # hijack the loop until we don't encounter target body lines
    if (%active_target != undef) 
    {
      # TODO: append current line to target body
      if ($line =~ /$target_line_regex/)
      {
        push(@active_target{"body"}, $line);
      }
      else 
      {
        %active_target = undef;
        continue;
      }
    }

    # interpret as a macro, evalmacro or target
    if ($line =~ /$macro_regex/) 
    {
      if($debug_mode) 
      {
        local @macro = split(/=/, $line);
        push(@root, new_macro_node($macro[0], $macro[1]));
      }
    } 
    elsif ($line =~ /$evalmacro_regex/) 
    {
      if($debug_mode) 
      {
        local @evalmacro = split(/\:=/, $line);
        push(@root, new_evalmacro_node($evalmacro[0], $evalmacro[1]));
      }
    } 
    elsif ($line =~ /$target_regex/) 
    {
      if($debug_mode) 
      {
        local @targetline = split(/\:/, $line);
        %active_target    = new_target_node($targetline[0], $targetline, ());
        push(@root, %active_target);
      }
    } 
    else
    {
      die("you're a terrible person");
    }
  }
  return %targ_root;
}

# Read selected makefile into a string
$mf_contents = subs_openfile($makefile);

# Parse the contents of the makefile into a tree
%targ_root = mf_parse($mf_contents);
